struct FBox
{
	FBox() = default;
	FBox(const glm::vec3& position)
	{
		set(position);
	}

	void set(const glm::vec3& position)
	{
		min = (glm::vec3{ -voxel_scale } + position);
		max = (glm::vec3{ voxel_scale } + position);
	}

	glm::vec3 min, max;
};

struct FRay
{
	FRay() = default;
	FRay(const glm::vec3& origin, const glm::vec3& direction)
	{
		set(origin, direction);
	}

	void set(const glm::vec3& origin, const glm::vec3& direction)
	{
		this->origin = origin;
		this->direction = direction;
	}

	glm::vec3 origin, direction;
};

class CChunk
{
public:
	CChunk(const glm::vec3& pos)
	{
		chunk_pos = pos;
	}

	CChunk(const glm::u32vec3& pos)
	{
		chunk_pos = glm::vec3(pos * chunk_size) * voxel_scale;
	}

	bool check(const glm::vec3& voxel_pos, const siv::PerlinNoise& noise)
	{
		auto noisep = voxel_pos / chunk_divider;

		auto height = (noise.octave2D_01(noisep.x, noisep.z, 1) * (float)chunk_size) * voxel_scale;

		return voxel_pos.y <= height;
	}

	void make(const siv::PerlinNoise& noise, std::vector<FVertex>& verts, const std::unique_ptr<CCamera>& camera)
	{
		float distance{ 0.f };
		FBox box; FRay ray;
		ray.origin = camera->getViewPos();

		for (uint32_t x = 0; x < chunk_size; x++)
		{
			for (uint32_t y = 0; y < chunk_size; y++)
			{
				for (uint32_t z = 0; z < chunk_size; z++)
				{
					auto final_pos = (glm::vec3(x, y, z) * voxel_scale) + chunk_pos;
					if (check(final_pos, noise))
					{
						uint32_t color = 0xFF008000;

						ray.direction = glm::normalize(final_pos - ray.origin);
						box.set(final_pos);
						if(intersect(box, ray, distance))
							verts.emplace_back(FVertex(final_pos, color));
					}
				}
			}
		}
	}

	bool intersect(const FBox& box, const FRay& ray, float& distance)
	{
		auto t1 = (box.min - ray.origin) / ray.direction;
		auto t2 = (box.max - ray.origin) / ray.direction;

		auto tmin = glm::max(glm::max(glm::min(t1.x, t2.x), glm::min(t1.y, t2.y)), glm::min(t1.z, t2.z));
		auto tmax = glm::min(glm::min(glm::max(t1.x, t2.x), glm::max(t1.y, t2.y)), glm::max(t1.z, t2.z));

		if (tmax < 0 || tmin > tmax)
		{
			distance = tmax;
			return false;
		}

		distance = tmin;
		return true;
	}

	const glm::vec3& start() { return chunk_pos; }
	const glm::vec3& end() { return chunk_pos + glm::vec3(1.f, 1.f, 1.f) * (float)chunk_size * voxel_scale; }

private:
	glm::vec3 chunk_pos{ 0.f };
};