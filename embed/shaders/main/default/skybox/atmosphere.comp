#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : require

#include "../../../shader_util.glsl"
#include "../../lightning_base.glsl"
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 1, binding = 0, rgba16f) uniform writeonly image2D writeColor;

layout(std140, set = 0, binding = 0) uniform FCameraData 
{
  	mat4 view;
  	mat4 invView;
  	mat4 projection;
  	mat4 invProjection;
    mat4 invViewProjection;
} camera;

layout(std140, set = 0, binding = 1) uniform FAtmosphereScattering 
{
    int lightCount;
} scattering;

layout(std430, set = 0, binding = 2) buffer readonly UBOLights
{
	FDirectionalLight directionalLights[MAX_DIRECTIONAL_LIGHTS_COUNT];
};

void main()
{
	ivec2 iUV = ivec2(gl_GlobalInvocationID.xy);
	vec2 inUV = (iUV + 0.5f) / vec2(imageSize(writeColor).xy);

    vec4 dirWorldSpace = vec4(0);
    const vec3 viewerPosition = vec3(camera.invView[3]);
    const vec3 origin = vec3(0, earthRadius, 0) + viewerPosition * 0.01;

    dirWorldSpace.xyz = getPositionFromDepth(vec2(inUV.x, 1.0 - inUV.y), 1.0f, camera.invViewProjection).xyz;

    vec3 finalColor = vec3(0.0);
    for(int i = 0; i < scattering.lightCount; ++i)
    {
        const FDirectionalLight light = directionalLights[i];
        const vec3 dirToSun = normalize(-light.direction);
    
        finalColor += skyLighting(origin, dirWorldSpace.xyz, -dirToSun, light.color, light.intencity);
    }
    finalColor /= float(scattering.lightCount);
    finalColor = 1.0 - exp(-1.0 * finalColor);

    imageStore(writeColor, iUV, vec4(finalColor, 1.0));
}